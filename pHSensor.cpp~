#include "pHSensor.h"

#define Write_Check      0x1234

#define ADDRESS 0x4D // MCP3221 A5 in Dec 77 A0 = 72 A7 = 79)
                     // A0 = x48, A1 = x49, A2 = x4A, A3 = x4B, 
                     // A4 = x4C, A5 = x4D, A6 = x4E, A7 = x4F

//Our parameter, for ease of use and eeprom access lets use a struct
struct parameters_T
{
  unsigned int WriteCheck;
  int pH7Cal, pH4Cal;
  float pHStep;
} 
params;

const float vRef = 4.096; //Our vRef into the ADC wont be exact
                    //Since you can run VCC lower than Vref its
                    //best to measure and adjust here
const float opampGain = 5.25; //what is our Op-Amps gain (stage 1)


pHSensor::pHSensor(byte port, int address){}

void pHSensor::setup() {  

}

//Now that we know our probe "age" we can calucalate the proper pH Its really a matter of applying the math
//We will find our milivolts based on ADV vref and reading, then we use the 7 calibration
//to find out how many steps that is away from 7, then apply our calibrated slope to calcualte real pH
void pHSensor::calcpH(int raw)
{
 float miliVolts = (((float)raw/4096)*vRef)*1000;
 float temp = ((((vRef*(float)params.pH7Cal)/4096)*1000)- miliVolts)/opampGain;
 return 7-(temp/params.pHStep);
}

void pHSensor::measure(int * data) {
	//We'll assign 2 BYTES variables to capture the LSB and MSB(or Hi Low in this case)
	byte adc_high;
	byte adc_low;
	//We'll assemble the 2 in this variable
	int adc_result;
  
	Wire.requestFrom(ADDRESS, 2);        //requests 2 bytes
	while(Wire.available() < 2);         //while two bytes to receive
	//Set em 
	adc_high = Wire.read();           
	adc_low = Wire.read();
	//now assemble them, remembering our byte maths a Union works well here as well
	adc_result = (adc_high * 256) + adc_low;
	data[0] = id;
	data[1] = calcpH(adc_result);
	data[2] = 0;
}

char* pHSensor::getName() {
	return "pH";
}


